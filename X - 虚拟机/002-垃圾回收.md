### 垃圾回收知识

- 对象的分配一般要进行连续的内存空间寻址过程.
- 新生代，也就是刚刚new出来的对象，它们都会位于新生代当中.

### 判断对象是否需要回收的方法一：引用记数法（如果两个对象互相引用可以回收吗）

给对象添加一个引用计数器，当有一个地方引用它，计数器值加 1；当引用失效时，计数器值减 1。任何时刻计数器值为 0 表示这个对象可以被回收。

缺点：这种方式实现简单且高效,但是这种方式存在着一种问题,也就是对象的循环依赖.

假设现在有两个对象,他们互相引用值为null,且不存在其他对象对其引用也不存在这两个对象的使用,那么这时这两个对象应该就是垃圾对象,但是由于他们互相引用,所以无法被回收.

### 判断对象是否需要回收的方法二：可达性分析算法

通过一系列称为 "GC Roots" 的对象作为起始点，从这个节点向下搜索，搜索走过的路径就是引用链，当一个对象到 GC Roots 没有任何引用链相连，也就是从 GC Roots 到这个对象不可达，则这个对象不可达，可以被回收。

可达性即这个对象可以到达,对可达性进行分析来判断对象是否存在引用,如果对象可达则不能回收,如果不可达则将对象标记为垃圾对象等待回收,这也是主流虚拟机采用的方式.

那么这个可达性是什么呢,要了解这个概念,我们首先需要了解GC Roots根节点.

可作为 GC Roots 的对象有
	1. 虚拟机栈中的引用的对象
	2. 方法区的静态变量和常量引用的对象
	3. 本地方法栈中 JNI 引用的对象

### 垃圾回收算法 - 标记-清除算法

1、操作：算法分为“标记”和“清除”两个阶段，首先标记处所有需要回收的对象，然后回收需要回收的对象

2、缺点1：标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾搜集动作。GC次数越多，碎片越严重。

3、缺点2：扫描的效率不高。需要扫描所有的对象，堆越大，GC越慢。

### 垃圾回收算法 - 标记-复制算法

1、操作：将可用内存分为两块，比例一比一，每次只是用其中的一块，当半区内存用完了，仅将还存活的对象复制到另外一块内存上，然后把原来用完的半块内存空间一次性清理掉。

2、进行垃圾清除时,他会把当前这一半的所有存活对象依次移入到另一半内存中去,移入完成后在对这一块内存进行整体回收.由于每次清理对象实际都存在一个整理的过程,所以这种算法不会产生垃圾碎片问题,又因为他是保留有用的对象,直接全部回收一块内存空间,速度自然也比标记-清除算法快很多.

3、缺点：内存区域分为两块，可使用内存变小

4、改进的做法：将内存分为一块较大的eden空间和两块较少的survivor空间，每次使用eden和其中一块survivor，当回收时将eden和survivor还存活的对象一次性拷贝到另外一块survivor空间上，然后清理掉eden和用过的survivor空间。
- 使用的survivor叫做from-space，另外一块叫to-space。
- to-space：垃圾回收之后，接收对象复制的堆内存空间。
- Oracle Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费”的

5、其他
```text
复制搜集算法，在对象存活率高的时候，效率有所下降

如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都100%存活的极端情况.所以在老年代一般不能直接选用复制算法。老年代的对象可能还会存活很久。

复制算法只需要扫描存活的对象，效率更高。

不会产生碎片，因为都是一次性将一整片内存回收掉

需要浪费额外的内存作为复制区

复制算法非常适合生命周期比较短的对象，因为每次GC总能回收大部分的对象，复制的开销比较小。

根据IBM的专门研究，98%的java对象只会存活一个GC周期，对这些对象就很适合才能复制算法。而且不用1:1划分工作区和复制区的空间。

```

### 垃圾回收算法 - 标记-整理算法

1、操作：标记过程都相同,整理首先是将存活对象向前移动,将所有存活对象移到前面去,那么此时会产生一个内存分界点,分界点一端全部都是有用对象,另一端全部都是垃圾对象,这时候只需要对分界点的一端进行整体清理就可以了.这个算法同样不会产生垃圾碎片,效率也不低.

### 垃圾回收算法 - 分代收集算法

分代收集算法并不是像前三种算法那样做一个清除的步骤,他只不过是将堆内存分为了年轻代老年代,这样我们就可以通过不同的策略针对不同的区采取不同的垃圾收集算法.

一般把Java堆分作新生代和老年代。
- 每次GC都有大批对象死亡，只有少量存活，就可以采用复制算法。只需要付出少量存活对象的复制成本。
- 新生代采用复制算法
- 老年代采用标记整理算法或者标记清除算法。

JDK6
-  年轻代
- 老年代
- 永久代

JDK8
- 年轻代
- 老年代
- 元空间：JDK8之后没有永久代，替换成了元空间

年轻代
- 新生成的对象都放在新生代。年轻代用复制算法记性GC
- 年轻代分为三个区：一个Eden区，两个survivor区（可以通过参数设置Survivor个数）.
  - 对象在Eden区生成
  - 当Eden区满的时候，还存活的对象将被复制到一个Survivor区，当这个Survivor区满的时候，此区的存活对象将被复制到另外一个Survivor区。
  - 当第二个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到老年代。
  - 2个survivor区是完全对称，轮流替换。
- Eden和两个Survivor的默认比例是8：1：1，也就是10%的空间会被浪费。但是可以根据GC log的信息调整大小的比例。  

其他
```text
目前商业虚拟机都是采用“分代搜集算法”，根据对象的不同存活周期将内存划分为几块


```

### 


















