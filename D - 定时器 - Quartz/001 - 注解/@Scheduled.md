## @Scheduled

在方法中使用

```jshelllanguage
@Component
public class PrintJob {

    @Scheduled(fixedRate = 3000)
    public void print(){
       System.out.println("hello "+new Date());
    }

}
```

### @Scheduled(fixedRate = 3000)

每隔3s执行一次

它的间隔时间是根据上次任务开始的时候计时的。比如当方法上设置了fiexdRate=5*1000，该执行该方法所花的时间是2秒，那么3秒后就会再次执行该方法。

### @Scheduled(fixedRate = 3000) 的坑（导致任务阻塞）

但是,当任务执行时长超过设置的间隔时长，那会是什么结果呢。

打个比方，比如一个任务本来只需要花2秒就能执行完成，我所设置的fixedRate=5000，但是因为网络问题导致这个任务花了7秒才执行完成。当任务开始时Spring就会给这个任务计时，5秒钟时候Spring就会再次调用这个任务，可是发现原来的任务还在执行，这个时候第二个任务就阻塞了（这里只考虑单线程的情况下，多线程后面再讲），、

甚至如果第一个任务花费的时间过长，还可能会使第三第四个任务被阻塞。被阻塞的任务就像排队的人一样，一旦前一个任务没了，它就立马执行。

### @Scheduled(fixedDelay = 5000)

当上一个任务执行完，过了5s，就会执行下一个任务.

fixedDelay是设定上一个任务结束后多久执行下一个任务，也就是fixedDelay只关心上一任务的结束时间和下一任务的开始时间。

### @Scheduled(fixedRate)如何避免任务被阻塞、

答案是加上注解@EnableAsync（类上）和@Async（方法上），加了注解以后，就开启了多线程模式，当到了下一次任务的执行时机时，如果上一次任务还没执行完，就会自动创建一个新的线程来执行它。异步执行也可以理解为保证了任务以固定速度执行。

开启多线程后，每次任务开始的间隔都是5秒钟。这是符合我们预期的，但是最后还有点缺陷，这种情况下的线程是随着任务一执行完就销毁的，等下次有需要了程序再创建一个。每次都要重新创建明显是太影响性能了，所以需要在代码里给他一个线程池。















