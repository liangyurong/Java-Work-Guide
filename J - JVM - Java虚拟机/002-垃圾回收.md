### 垃圾回收知识

- 对象的分配一般要进行连续的内存空间寻址过程.
- 新生代，也就是刚刚new出来的对象，它们都会位于新生代当中.

### 判断对象是否需要回收的方法一：引用记数法（如果两个对象互相引用可以回收吗）

给对象添加一个引用计数器，当有一个地方引用它，计数器值加 1；当引用失效时，计数器值减 1。任何时刻计数器值为 0 表示这个对象可以被回收。

缺点：这种方式实现简单且高效,但是这种方式存在着一种问题,也就是对象的循环依赖.

假设现在有两个对象,他们互相引用值为null,且不存在其他对象对其引用也不存在这两个对象的使用,那么这时这两个对象应该就是垃圾对象,但是由于他们互相引用,所以无法被回收.

### 判断对象是否需要回收的方法二：可达性分析算法

通过一系列称为 "GC Roots" 的对象作为起始点，从这个节点向下搜索，搜索走过的路径就是引用链，当一个对象到 GC Roots 没有任何引用链相连，也就是从 GC Roots 到这个对象不可达，则这个对象不可达，可以被回收。

可达性即这个对象可以到达,对可达性进行分析来判断对象是否存在引用,如果对象可达则不能回收,如果不可达则将对象标记为垃圾对象等待回收,这也是主流虚拟机采用的方式.

那么这个可达性是什么呢,要了解这个概念,我们首先需要了解GC Roots根节点.

可作为 GC Roots 的对象有
	1. 虚拟机栈中的引用的对象
	2. 方法区的静态变量和常量引用的对象
	3. 本地方法栈中 JNI 引用的对象





5、其他
```text
复制搜集算法，在对象存活率高的时候，效率有所下降

如果不想浪费50%的空间，就需要有额外的空间进行分配担保用于应付半区内存中所有对象都100%存活的极端情况.所以在老年代一般不能直接选用复制算法。老年代的对象可能还会存活很久。

复制算法只需要扫描存活的对象，效率更高。

不会产生碎片，因为都是一次性将一整片内存回收掉

需要浪费额外的内存作为复制区

复制算法非常适合生命周期比较短的对象，因为每次GC总能回收大部分的对象，复制的开销比较小。

根据IBM的专门研究，98%的java对象只会存活一个GC周期，对这些对象就很适合才能复制算法。而且不用1:1划分工作区和复制区的空间。

```



















