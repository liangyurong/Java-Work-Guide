
### 标记-清除算法

先标记，再清除

1、操作：算法分为“标记”和“清除”两个阶段，首先标记处所有需要回收的对象，然后回收需要回收的对象

2、缺点1：标记清理之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续使用中无法找到足够的连续内存而提前触发另一次的垃圾搜集动作。GC次数越多，碎片越严重。

3、缺点2：扫描的效率不高。需要扫描所有的对象，堆越大，GC越慢。

### 标记-整理算法

先标记，然后整理，再清除

但是会产生较多的内存碎片，效率也低

具体过程

    标记过程都相同,整理首先是将存活对象向前移动,将所有存活对象移到前面去,

    那么此时会产生一个内存分界点,分界点一端全部都是有用对象,另一端全部都是垃圾对象,这时候只需要对分界点的一端进行整体清理就可以了.这个算法同样不会产生垃圾碎片,效率也不低.


### 标记-复制算法

1、操作：将可用内存分为两块，比例一比一，每次只是用其中的一块，当半区内存用完了，仅将还存活的对象复制到另外一块内存上，然后把原来用完的半块内存空间一次性清理掉。

2、进行垃圾清除时,他会把当前这一半的所有存活对象依次移入到另一半内存中去,移入完成后在对这一块内存进行整体回收.由于每次清理对象实际都存在一个整理的过程,所以这种算法不会产生垃圾碎片问题,又因为他是保留有用的对象,直接全部回收一块内存空间,速度自然也比标记-清除算法快很多.


缺点

    内存区域分为两块，可使用内存变小

改进

    将内存分为一块较大的eden空间和两块较少的survivor空间，每次使用eden和其中一块survivor，当回收时将eden和survivor还存活的对象一次性拷贝到另外一块survivor空间上，然后清理掉eden和用过的survivor空间。

- 使用的survivor叫做from-space，另外一块叫to-space。
- to-space：垃圾回收之后，接收对象复制的堆内存空间。
- Oracle Hotspot虚拟机默认eden和survivor的大小比例是8:1，也就是每次只有10%的内存是“浪费”的

### 分代收集算法

分代收集算法并不是像前三种算法那样做一个清除的步骤,他只不过是将堆内存分为了年轻代和老年代,这样我们就可以通过不同的策略针对不同的区采取不同的垃圾收集算法.

一般把Java堆分作新生代和老年代。
- 每次GC都有大批对象死亡，只有少量存活，就可以采用复制算法。只需要付出少量存活对象的复制成本。
- 新生代采用复制算法
- 老年代采用标记整理算法或者标记清除算法。

JDK6
- 年轻代
- 老年代
- 永久代

JDK8
- 年轻代
- 老年代
- 元空间：JDK8之后没有永久代，替换成了元空间

年轻代
- 新生成的对象都放在新生代。年轻代用复制算法进行GC
- 年轻代分为三个区：一个Eden区，两个survivor区（可以通过参数设置Survivor个数）.
    - 对象在Eden区生成
    - 当Eden区满的时候，还存活的对象将被复制到一个Survivor区，当这个Survivor区满的时候，此区的存活对象将被复制到另外一个Survivor区。
    - 当第二个Survivor区也满了的时候，从第一个Survivor区复制过来的并且此时还存活的对象，将被复制到老年代。
    - 2个survivor区是完全对称，轮流替换。
- Eden和两个Survivor的默认比例是8：1：1，也就是10%的空间会被浪费。但是可以根据GC log的信息调整大小的比例。

其他
```text
目前商业虚拟机都是采用“分代搜集算法”，根据对象的不同存活周期将内存划分为几块
```






