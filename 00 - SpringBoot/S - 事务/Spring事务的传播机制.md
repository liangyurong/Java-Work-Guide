## Spring事务的传播机制

多个事务方法相互调用时，事务如何在这些方法之间传播？

### 一、问题

怎么可视化得知道执行了哪种事务？比如是执行了A的事务，还是执行了B的事务？

### 二、7种传播行为

#### required

默认的传播特性。如果当前存在事务，则加入事务。如果当前没有事务，则新建事务；

举例子：B方法中有@Transactional，A方法调用了B方法，如果A方法存在事务，则B使用A方法的事务；如果A方法不存在事务，则B自己创建一个事务

记忆：别人作业写好了，我就抄；别人没有写作业，我就自己做

#### supports

如果当前存在事务，则加入事务。如果当前没有事务，则以非事务的方式执行

举例子：B方法中有@Transactional，A方法调用了B方法，如果A方法存在事务，则B使用A方法的事务；如果A方法不存在事务，则B自己以非事务的方式执行

记忆：你怎么做我都支持你。

应用场景：

#### not_supported

如果存在当前事务，则挂起当前事务。否则以非事务方式执行。

记忆：不支持事务。

#### mandatory 强制的

如果当前存在事务，则加入事务。如果当前没有事务，则抛出异常

#### required_new

创建一个新事务。如果当前存在事务，则挂起当前事务。

举例子：B方法中有@Transactional，A方法调用了B方法。B自己创建一个事务，如果A方法存在事务，则挂起A事务

记忆：不管别人有没有写作业，我总得靠自己写作业

#### never

不使用事务；如果当前事务存在，则抛出异常

#### nested 嵌套的

如果当前事务存在，则在嵌套事务中执行，否则和required的操作一样。

### 三、nested和required_new的区别

nested则是在当前事务开启一个嵌套事务，当父事务回滚时，子事务也会回滚。

required_new是新建一个事务，与原事务无关。原事务回滚的时候，不会影响到新事务。

### 四、nested和required的区别

A方法调用B方法，A是调用方，B是被调用方

required情况下，调用方存在事务时，则被调用方和调用方使用同一个事务。当被调用方出现异常，由于共用一个事务，所以无论是否catch异常，事务都会回滚。

nested情况下子事务发生异常，父事务可以catch异常，这样只有子事务回滚，父事务不会回滚




