
### 三个map分别存放什么？

一级缓存    成品对象

二级缓存    半成品对象

三级缓存    lambda表达式，getEarlyBeanReference，什么作用？

### 三个map缓存的查找对象顺序是什么？

先查一级缓存，找不到就找二级缓存，再找不到就找三级缓存

### 如果只有1个map，能否解决循环依赖的问题？

不能，只有1个map的时候，成品独享和半成品对象都只能放在一个map中。但是半成品对象是不能暴露给外部使用的，因此需要做区分。

为什么半成品对象不能暴露给外部？

    半成品对象里面的属性都是null。暴露出去就是个空指针，何必自找麻烦。

### 如果只有2个map，能否解决循环依赖的问题？

能，前提是不包含代理对象

### 为什么三级缓存可以解决循环依赖中包含代理对象的问题？

创建代理对象的时候需要创建出原始对象？

    需要

同一个容器中能否出现同名的两个不同对象？

    不能

如果一个对象被代理，那么代理对象和原始对象应该如何去存储？

    如果需要创建代理对象，那么创建完代理对象，应该要覆盖原始对象
    
    在getEarlyBeanReference方法中，会判断是否需要代理对象，如果创建出了代理对象，则需要覆盖原始对象、

为什么创建完代理对象，应该要覆盖原始对象？


在对外暴露的时候，容器怎么准确得知道应该给出原始对象还是代理对象？

    代理对象的创建是在BeanPostProcessor的后置方法中，在解决循环依赖的时候，还没有执行这个方法。

    所以创建代理对象的时候需要lambda表达式，类似是一种回调机制，在确定要对外暴露的时候，就唯一性得确定到底是代理对象还是原始对象。

    这也是为什么不把对象直接放在二级缓存，而是通过三级缓存得lambda表达式来

BeanPostProcessor后置方法

    确定返回的是代理对象还是原始对象

