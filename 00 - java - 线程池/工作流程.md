## 线程池工作流程

线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。

当调用 execute() 方法添加一个任务时，线程池会做如下判断：

	1. 如果正在运行的线程数量小于 核心线程数，那么马上创建线程运行这个任务；
	2. 如果正在运行的线程数量大于或等于 核心线程数，那么将这个任务放入队列。
	3. 如果这时候队列满了，而且正在运行的线程数量小于 最大线程数，那么创建多余线程去执行任务；
	4. 如果队列满了，而且正在运行的线程数量大于或等于 最大线程数，那么线程池会抛出异常，告诉调用者“我不能再接受任务了”。 （执行拒绝策略）

当一个线程完成任务时，它会从队列中取下一个任务来执行。

当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。

这样的过程说明，并不是先加入任务就一定会先执行。

### 假设队列大小为 10，corePoolSize 为 3，maximumPoolSize 为 6，那么当加入 20 个任务时

首先执行任务 1、2、3，然后任务 4~13 被放入队列。这时候队列满了，任务 14、15、16 会被马上执行（多余线程），而任务 17~20 则会抛出异常。最终顺序是：1、2、3、14、15、16、4、5、6、7、8、9、10、11、12、13。

### 如果线程池已经满了可是还有新的任务提交怎么办？

线程池已满的定义，是指运行线程数==maximumPoolSize，并且workQueue是有界队列并且已满（如果是无界队列当然永远不会满）。

这时候再提交任务怎么办呢？线程池会将任务传递给最后一个参数RejectedExecutionHandler来处理，比如打印报错日志、抛出异常、存储到Mysql/redis用于后续处理等等，线程池默认也提供了几种处理方式.

### 队列已满，核心线程数已满，没有达到最大线程数

队列满了，核心线程数也满了，此时会创建一个多余线程执行任务，而不是先执行队列里的任务

### 队列里的任务是什么执行顺序？

比如队列任务的进来顺序是：A、B、C、D 。 那么当有线程可以执行队列任务的时候，先执行哪一个？



