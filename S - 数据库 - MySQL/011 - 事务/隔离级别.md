## 事务隔离级别：4种

### Read Uncommitted（读取未提交内容）

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）

### Read Committed（读取提交内容）

这是大多数数据库系统如Oracle的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。

可能会导致不可重复读和幻读

### Repeatable Read（可重读） mysql默认隔离级别

这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。

不过理论上，可能会导致幻读 （Phantom Read）。已经解决了幻读问题？

幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。

InnoDB和Falcon存储引擎通过MVCC机制解决了该问题。

### Serializable（可串行化）

这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。

简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

### 脏读 不可重复读 幻读

脏读：A事务更改了数据但是未提交，B事务读取了该数据，A事务失败导致事务回滚，则B事务读取的数据就是不正确的，也就是出现脏读。

不可重复读：A在同一个事务的两次相同查询，读取的数据不一致

