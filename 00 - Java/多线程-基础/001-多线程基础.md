### 一、学习多线程的学习方法

无它，唯看得多做的多。等积累到一定的程度，你就会融会贯通，彻底打通任督二脉。

从大二（2016）开始就学习java的多线程，一直都是很模糊，不明白其中的运行机制。

直到现在，我才懂得了多线程的一些运行机制。

有什么多线程实战的项目？

### 二、一个关键的认知

实现Runnable和Callable接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过Thread来调用。可以理解为任务是通过线程驱动从而执行的。

### 三、new Thread()里面放一个实现Runnable接口的对象或者一个继承Thread的对象是什么意义？

将实现Runnable接口的类看做是任务类，重写的run方法就是任务。

任务如果是需要放在多线程中执行，那就需要Thread类。

创建一个Thread类，将任务类对象作为参数传递给Thread的构造方法，调用Thread类的start方法就会启动一个线程，它会导致任务类的run方法执行，当run方法执行完毕，线程终止。

### 四、Runnable比Thread具有的优势

适合多个相同的程序代码的线程去处理同一个资源。

可以避免java中的单继承的限制。

增加程序的健壮性，代码可以被多个线程共享，代码和数据独立。

线程池只能放入实现Runable或callable类线程，不能直接放入继承Thread的类。

### 五、线程sleep之后怎么唤醒？

比如sleep(1000)，等到线程睡眠1s之后，就又处在一个可执行的状态，只需要cpu分配即可执行。

### 六、为什么一个线程多次start()会出现异常

因为线程的生命周期是个不可循环的过程。一个线程对象结束了就不能够再次start()。

### 七、线程规划器的底层原理是什么？



### 八、Thread t1=new Thread(a)，其实发生了什么？为什么t1能够调用到类A的run方法？

类A的方法
```java
Class A implements Runnable {
   ...
}

A  a =new A();
Thread t=new Thread (a);
t.start();
```

在java的Thread源代码中的run方法源码
```java
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
```
然而在start方法中没有调用run方法。空空如也。这是因为run方法由java虚拟机来调用，而调用的时间是不确定的
```java
/**
* This method is not invoked for the main method thread or "system"
* group threads created/set up by the VM. Any new functionality added
* to this method in the future may have to also be added to the VM.
*
* A zero status value corresponds to state "NEW".
*/
public synchronized void start()
```

### 九、基础

线程是占用cpu执行的基本单位。

cpu是使用时间片轮转的方式让线程轮询占用的。如果当前线程的cpu时间片用完之后，要让出cpu，等下次轮到自己再执行。

进程是计算机中一个正常执行的程序。完全可以将运行在内存中的exe文件理解成进程。

线程是进程中独立运行的子任务。线程控制着进程的执行。

进程至少有一个线程。

进程占有的资源：地址空间，全局变量，打开文件，子进程，信号量，

线程占有的资源：栈，寄存器，状态，程序计数器，账户信息

多线程最大的特点就是不确定性。

在jvm中，运行main方法的线程叫做主线程。

Jvm启动的时候，有多个线程。回收垃圾的线程，运行main方法的主线程等等。

JVM允许应用程序并发运行多个执行线程。

使用多线程也就是在使用异步。

main方法中没有currentThread()方法，只有Thread或者继承了Thread类的才有。

关键字volatile不能保证线程安全。

线程的执行体是run()方法里面的每一条语句，main线程执行的是main()方法里面的语句。

### 上下文切换

cpu给每个线程分配一个时间片，线程在时间片内占用cpu执行任务。当前线程使用完时间片后，就会处于就绪状态并让出cpu让其他线程占用，这就是上下文切换。

### 线程的状态

新建，new

就绪

运行

阻塞

死亡

### 线程的阻塞

定义：暂停一个线程的执行。

什么时候线程会阻塞？
```text
1、线程执行wait()方法，会释放当前线程所获得的锁。
2、suspend()方法
```

### 什么时候线程被挂起？

线程执行其他线程的join()方法，当前线程会被挂起。

### 线程挂起与线程阻塞的区别？



睡眠和挂起是行为，阻塞是一种状态。

挂起线程的意思就是你对主动对雇工说："你睡觉去吧，用着你的时候我主动去叫你，然后接着干活”，suspend()方法。叫醒雇工干货的方法是resume()。

使线程睡眠的意思就是你主动对雇工说："你睡觉去吧，某时某刻过来报到，然后接着干活"。

线程阻塞的意思就是，你突然发现，你的雇工不知道在什么时候没经过你允许，自己睡觉呢，但是你不能怪雇工，肯定你这个雇主没注意，本来你让雇工扫地，结果扫帚被偷了或被邻居家借去了，你又没让雇工继续干别的活，他就只好睡觉了。至于扫帚回来后，雇工会不会知道，会不会继续干活，你不用担心，雇工一旦发现扫帚回来了，他就会自己去干活的。因为雇工受过良好的培训。这个培训机构就是操作系统。








