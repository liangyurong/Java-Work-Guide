### 一、学习多线程的学习方法

无它，唯看得多做的多。等积累到一定的程度，你就会融会贯通，彻底打通任督二脉。

从大二（2016）开始就学习java的多线程，一直都是很模糊，不明白其中的运行机制。

直到现在，我才懂得了多线程的一些运行机制。

有什么多线程实战的项目？




### 五、线程sleep之后怎么唤醒？

比如sleep(1000)，等到线程睡眠1s之后，就又处在一个可执行的状态，只需要cpu分配即可执行。

### 六、为什么一个线程多次start()会出现异常

因为线程的生命周期是个不可循环的过程。一个线程对象结束了就不能够再次start()。

### 七、线程规划器的底层原理是什么？



### 八、Thread t1=new Thread(a)，其实发生了什么？为什么t1能够调用到类A的run方法？

类A的方法
```jshelllanguage
Class A implements Runnable {
   ...
}

A  a =new A();
Thread t=new Thread (a);
t.start();
```

在java的Thread源代码中的run方法源码
```jshelllanguage
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
```
然而在start方法中没有调用run方法。空空如也。这是因为run方法由java虚拟机来调用，而调用的时间是不确定的
```java
/**
* This method is not invoked for the main method thread or "system"
* group threads created/set up by the VM. Any new functionality added
* to this method in the future may have to also be added to the VM.
*
* A zero status value corresponds to state "NEW".
*/
public synchronized void start()
```

### 九、基础



多线程最大的特点就是不确定性。

在jvm中，运行main方法的线程叫做主线程。

Jvm启动的时候，有多个线程。回收垃圾的线程，运行main方法的主线程等等。

JVM允许应用程序并发运行多个执行线程。

使用多线程也就是在使用异步。

main方法中没有currentThread()方法，只有Thread或者继承了Thread类的才有。

关键字volatile不能保证线程安全。

线程的执行体是run()方法里面的每一条语句，main线程执行的是main()方法里面的语句。

### 上下文切换

cpu给每个线程分配一个时间片，线程在时间片内占用cpu执行任务。当前线程使用完时间片后，就会处于就绪状态并让出cpu让其他线程占用，这就是上下文切换。



### 线程的阻塞

定义：暂停一个线程的执行。

什么时候线程会阻塞？
```text
1、线程执行wait()方法，会释放当前线程所获得的锁。
2、suspend()方法
```

### 什么时候线程被挂起？

线程执行其他线程的join()方法，当前线程会被挂起。

### 线程挂起与线程阻塞的区别？



睡眠和挂起是行为，阻塞是一种状态。

挂起线程的意思就是你对主动对雇工说："你睡觉去吧，用着你的时候我主动去叫你，然后接着干活”，suspend()方法。叫醒雇工干货的方法是resume()。

使线程睡眠的意思就是你主动对雇工说："你睡觉去吧，某时某刻过来报到，然后接着干活"。

线程阻塞的意思就是，你突然发现，你的雇工不知道在什么时候没经过你允许，自己睡觉呢，但是你不能怪雇工，肯定你这个雇主没注意，本来你让雇工扫地，结果扫帚被偷了或被邻居家借去了，你又没让雇工继续干别的活，他就只好睡觉了。至于扫帚回来后，雇工会不会知道，会不会继续干活，你不用担心，雇工一旦发现扫帚回来了，他就会自己去干活的。因为雇工受过良好的培训。这个培训机构就是操作系统。








