### 线程状态的转换

创建

    Thread t1 = new Thread()

    Thread t2 = new Thread()

创建 -> 就绪

    t1.start()

就绪 -> 运行

    t1获得cpu时间片执行代码

运行 ->

    线程执行过程中，执行Thread.sleep(100)，当前线程进入，释放资源不释放锁。此时线程状态是 tIMED_WAITING

运行 -> 阻塞

    t1线程运行中的线程尝试获取锁，但是锁被t2线程持有，t1陷入阻塞

运行 -> 等待

    情况1：t1线程运行中，需要等待t2线程的运行结果，主动执行obj.wait()。t1线程进入等待。释放资源释放锁

    情况2：t1线程运行中，主动执行t2.join()，此时t1进入等待， 等待t2线程执行完成

等待 -> 运行

    情况1：t1线程运行中，主动执行t2.join()，此时t1进入等待。当t2线程执行完成，t1线程从waiting转为runnable

    情况2：t1线程运行中，主动执行t2.join()，此时t1进入等待。在t1线程等待中，t2线程执行t1.interupt()，t1线程从waiting转为runnable

等待 -> 运行/阻塞

    情况1：t2线程运行中，主动执行obj.notifyAll()，所有阻塞的线程将去竞争锁，竞争成功转为运行，竞争失败转为阻塞


    