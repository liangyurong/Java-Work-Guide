
### 基础

只有当几个线程共享同一个对象，那么当这些线程去执行锁方法的时候才能实现线程同步。

即使拿到锁对象，线程也不一定执行代码，得分配到cpu时间片才能执行

synchronized实际是用对象锁保证了临界区内的代码的原子性，临界区内的代码对外是不可分割的，不会被线程切换所打断

### 锁方法在某些情况是有弊端的

当线程A调用同步方法去执行一个比较长时间的任务，那么线程B就得等待这么长时间，尽管线程B只需要1s的执行时间。

Synchronized(this)是对当前对象进行加锁

当两个并发线程访问同一个对象object中的synchronized（this）的同步代码块时，一段时间内只能有一个线程被执行，另一个线程则必须等待执行完同步代码块后才能执行该同步代码块

同步代码块是同步的，持有当前调用对象的锁

当两个并发线程访问同一个对象object中的代码时，不在同步代码块中的就是异步进行，在其中的就是同步运行。

当一个线程访问object的一个同步代码块时，其他线程对同一个object中所有其他的同步代码块的访问将被阻塞，这说明synchronized（this）使用的“对象监视器”是同一个。

当一个线程访问object的一个同步代码块时，其他线程对该object中的其他同步代码块的访问将是阻塞的。这个说明synchronized（this）使用的对象监视器是同一个。

对于非static的synchronized方法，锁的就是对象本身也就是this。

对于static方法，锁住的是字节码文件对象。静态类进内存，内存中没有本类对象，但是一定有该类对应的字节码文件对象。

synchronized只能防止多个线程同时执行一个对象的同步代码块。

对于多个对象的同步代码块，其实是异步的。

当synchronized锁住一个对象后，比如此刻执行的是线程A，若线程B也想拿到这个对象的锁，就必须等待线程A执行完成释放锁，才能再次给对象加锁，这样才达到线程同步的目的。即使两个不同的代码段，都要锁同一个对象，那么这两个代码段也不能在多线程环境下同时运行，所以在用synchronized关键字时，能缩小代码段的范围就尽量缩小，能在代码段上加同步就不要在整个方法上加同步。这叫减小锁的粒度，使代码更大程度的并发。原因是基于以上的思想，锁的代码段太长了会让别的线程等待时间过长。

synchronized加在一个类的普通方法上，那么相当于synchronized(this)

如果synchronized加在一个类的静态方法上，那么相当于synchronized(类名.Class)。

当一个线程执行的代码出现异常，其持有的锁将会自动释放。

synchronized可以保证在同一时刻，只有一个线程能够执行某一个方法或者某一个代码块。
	1. 包含两个特征：互斥性和可见性。
	2. 同步synchronized不仅可以解决一个线程看到对象处于不一致的状态，还可以保证进入同步方法或者同步代码块的每个线程，都看到由一个锁保护之前所有的修改效果。

想要同步哪个代码块，看看它属于哪一个类，然后再使用锁去锁住对应的类的对象，这样子就可以实现线程同步




### synchronized可以用在如下地方

1. 修饰实例方法，对当前实例对象this加锁
2. 修饰静态方法，对当前类的Class对象加锁
3. 修饰代码块，指定加锁对象，对给定对象加锁

### Java对象头

在jvm中，对象在堆内存中的布局分为三块区域：对象头，实例数据，对齐填充

- 实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。
- 填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。
- 对象头：synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成


### Synchronized锁什么时候释放

1. 获取锁的线程执行完了该代码块，会调用monitorexit释放锁
2. 线程执行出现异常

### Synchronized和lock的区别

1. Lock是java实现的类，synchronized是java中的关键词
2.

### Lock的实现

1. 读可以使用readLock，写可以使用writeLock
2. ReentrankLock，可重入锁，当然synchronzied也是可重入锁
3. ReentrankReadWriteLock，可重入的读写锁




