待解决 CAS

什么是cas

    Java中的运算并不是原子操作，如count++可分为：
            获取count副本count_
            对count_进行自增
            把count_赋值给count

    如果在第一步之后，count被其他的线程修改了，第三步的赋值会直接覆盖掉其他线程的修改。synchronize可以解决这个问题，但上锁为重量级操作，严重影响性能，CAS是更好的解决方案。
    
CAS的思路并不复杂。还是上面的例子：当我们需要对变量count进行自增时，我们可以认为没有发生并发冲突，先存储一个count副本，再对count进行自增，然后把副本和count本身进行比较，如果两者相同，则证明没有发生并发冲突，修改count的值；如果不同，则说明count在我们自增的过程中被修改了，把上述整个过程重新来一遍，直到修改成功为止，如下图：


为了解决什么问题？

原理是什么？

怎么使用？ 